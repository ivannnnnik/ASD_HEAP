В данном проекте мы рассматриваем структуру данных, которая называется двоичная куча(Binary heap). 
Главаная цель двоичной кучи - быстрая сортировка.
Единственный атрибут класса - массив, в котором хранятся значения.
При нумерации элементов с нулевого, корневой элемент — A[0], а потомки элемента A[i] — A[2i+1] и A[2i+2].
У класса двоичной кучи есть следющие методы: 

1.Проход по куче вниз(HeapDown)
Если в куче изменяется один из элементов, то она может перестать удовлетворять свойству упорядоченности. 
Для восстановления этого свойства служит процедура HeapDown. Она восстанавливает свойство кучи в дереве, у которого левое и правое поддеревья удовлетворяют ему. Эта процедура принимает на вход массив элементов massive и индекс i. Она восстанавливает свойство упорядоченности во всём поддереве, корнем которого является элемент massive[i].
Если i-й элемент больше, чем его сыновья, всё поддерево уже является кучей, и делать ничего не надо. В противном случае меняем местами i-й элемент с наибольшим из его сыновей, после чего выполняем HeapDown для этого сына.

Процедура выполняется за время O(log(n)).


2.Построение кучи(Build_Heap)
Эта процедура предназначена для создания кучи из неупорядоченного массива входных данных.
Заметим, что если выполнить HeapDown для всех элементов массива massive, начиная с последнего и кончая первым, он станет кучей. В самом деле, легко доказать по индукции, что к моменту выполнения HeapDown(massive, i) все поддеревья, чьи корни имеют индекс больше i, - кучи, и, следовательно, после выполнения Heapdown(massive, i) кучей будут все поддеревья, чьи корни имеют индекс, не меньший i.
Кроме того, HeapDown(massive,i) не делает ничего, если i>N/2 (при нумерации с первого элемента), где N — количество элементов массива. В самом деле, у таких элементов нет потомков, следовательно, соответствующие поддеревья уже являются кучами, так как содержат всего один элемент.
Таким образом, достаточно вызвать HeapDown для всех элементов массива massive

Процедура выполняется за время O(n*log(n))


3.Пирамидальная сортировка(Heapsort)
Для понимания её работы можно представить, что мы обменяли первый элемент (то есть корень) с последним. Тогда последний элемент станет самым большим. Если после этого исключить последний элемент из кучи (то есть формально уменьшить её длину на 1), первые N-1 элементов будут удовлетворять условиям кучи все, за исключением, может быть, корня. 
Если вызвать HeapDown, первые N-1 элементов станут кучей, а последний будет больше их всех. Повторяя эти действия N-1 раз, мы отсортируем массив.

Процедура выполняется за время O(n*log(n)


4.Проход по куче вверх(HeapUp)
Обычно эта процедура используется для добавления произвольного элемента в кучу.
Если элемент меньше своего отца, условие 1 соблюдено для всего дерева, и больше ничего делать не нужно. Если он больше, мы меняем местами его с отцом. Если после этого отец больше деда, мы меняем местами отца с дедом и так далее. Иными словами, слишком большой элемент всплывает наверх.

Процедура выполняется за время O(log(n)).


5.Добавление элемента(insert)
Добавление произвольного элемента в конец кучи, и восстановление свойства упорядоченности с помощью HeapUp.

Процедура выполняется за время O(log(n)


6.Извлечение и удаление максимального элемента(remove)
Извлечение выполняется в четыре этапа:
1-значение корневого элемента (он и является максимальным) сохраняется для последующего возврата
2-последний элемент копируется в корень, после чего удаляется из кучи
3-вызывается HeapDown для корня
4-сохранённый элемент возвращается

Процедура выполняется за время O(log(n)
